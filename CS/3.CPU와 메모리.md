## 컴퓨터의 구성
![image](./img/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98%EA%B5%AC%EC%A1%B0.png)
- 컴퓨터가 이해하는 정보: 데이터, 명령어
- 컴퓨터의 네 가지 핵심 부품: 중앙처리장치(CPU), 주기억장치(메모리), 보조기억장치, 입출력장치

* * *
## 입출력 장치
- 컴퓨터가 사용자와 의사소통하는 창구!

### 입력 장치
- 입력 장치들을 통해 컴퓨터에게 명령을 요청 또는 데이터를 입력
- 예: 키보드, 마우스 등등

### 출력 장치
- 컴퓨터가 사용자에게 데이터를 보여주거나 처리결과를 보여줌
- 예: 모니터, 스피커, 프린터 등등

* * *
## CPU (중앙처리장치)
- 컴퓨터가 사용자의 명령에 대한 작업을 수행하는 처리장치

### CPU의 구성
- 산술논리 연산장치(ALU) : 비교, 판단, 연산을 담당
- 제어부(CU)와 내부 버스  : 명령어의 해석과 올바른 실행을 위하여 CPU를 내부적으로 제어
- 레지스터 : 처리할 명령어를 저장
- 캐시 메모리(L1) : 처리속도를 높여주는 역할

### CPU의 동작 방식
1. 명령어 인출
2. 명령어 해독
3. 실행
4. 반영

### CPU의 성능
#### 클럭
- CPU 내부에서 일정한 주파수를 가지는 신호로, 이 신호로 모든 명령어가 동작되게 됨
- 클럭 주파수가 빠를수록 제한된 시간에 더 많은 명령어 처리 가능 -> 더 좋은 성능의 중앙처리 장치라는 의미

#### 코어
- 중앙처리 장치 역할을 하는 블록을 의미
- 멀티 코어들은 싱글 코어에 비해서 마치 여러 개의 CPU가 작동하듯이 많은 연산을 빠르게 병렬 처리할 수 있음

* * *
## 메모리
### 캐시 메모리 (L2, L3)
- 컴퓨터가 전원이 꺼지면 지워지지만 제일 빠르게 조회할 수 있는 저장공간
- 컴퓨터 시스템 향상을 위해서 CPU와 주기억장치 사이에 있는 아주 작은 비싼 메모리
- 메인 메모리에 있는 데이터를 캐시 메모리에 불러와 놓고, CPU가 필요한 데이터를 캐시에서 먼저 찾도록 하여 시스템 성능을 향상 시켜줌
-> 메인 메모리와 CPU 간의 속도차이를 극복하기 위한 것

### 주기억장치
- 컴퓨터가 전원이 꺼지면 지워지지만 조금더 빠르게 조회할 수 있는 저장공간
- 컴퓨터의 CPU가 현재 처리중인 데이터나 명령만을 일시적으로 저장하는 휘발성 메모리 -> 전원이 꺼진 이후에도 데이터를 유지하고 싶다면 "하드 디스크"에 저장!
- 보조기억장치보다 접근 속도가 빠름 (보조기억장치=하드디스크)
- 메인메모리 = 주기억장치 = RAM (Random Access Memory)
> RAM의 종류로는 DRAM과 SRAM, 주기억장치는 주로 DRAM을 의미

### 보조 기억장치
- 컴퓨터 전원이 꺼져도 지워지지 않는 저장공간 (=비휘발성 메모리)

* * *
## CPU와 메모리
### 동작 순서
1. 주기억장치가 입력장치에서 입력받은 데이터 또는 보조기억장치에 저장된 프로그램을 읽음
2. CPU는 프로그램을 실행하기 위해 주기억장치에 저장된 프로그램 명령어와 데이터를 읽어와 처리하고 결과를 다시 주기억 장치에 저장
3. 주기억장치는 처리 결과를 보조기억장치에 저장하거나 출력장치로 보내서 출력
4. CPU 내의 제어장치(CU)가 1~3번 과정에서 명령어가 순서대로 실행되도록 각 장치들을 제어

### 구조
1. 하버드 구조
![image](./img/%ED%95%98%EB%B2%84%EB%93%9C%EA%B5%AC%EC%A1%B0.png)
- 프로그램 명령어와 데이터가 물리적으로 분리된 별개의 메모리 공간을 가짐

#### 장점
- 메모리가 두개이기 때문에 역할이 나누어져 있으며 속도가 빠름

#### 단점
- 구성이 많기 때문에 비싸며, 복잡한 구성으로 고장이 날 확률이 높음

2. 폰노이만 구조
![image](./img/%ED%8F%B0%EB%85%B8%EC%9D%B4%EB%A7%8C%EA%B5%AC%EC%A1%B0.png)
- 프로그램 명령ㅇ어와 데이터가 동일한 메모리 공간에 저장

3. 개선된 구조
- 버드 구조 + 폰노이만 구조
- CPU의 캐시 메모리 형상에 관여
- CPU 내부 - 하버드 : CPU 내부에 캐시를 둬서 RAM과 CPU 간의 속도 차이를 줄이려고 노력
- CPU 외부 - 폰노이만 : 메모리 하나에 하나의 버스를 가지는 구조이기 때문에 병목현상이 아직까지는 존재

* * *
## 스케쥴링
- 컴퓨터에서 여러 개의 프로세스가 동시에 실행될 때, CPU 자원을 효율적으로 할당하는 작업
- OS는 실행 대기중인 프로그램(프로세스)들에게 CPU 자원 배정을 적절히 하여 시스템의 성능을 끌어올릴 수 있음
- 여러 프로세스가 시스템에 동시에 존재하는 경우, CPU는 각 프로세스에 대해 어느 정도의 시간을 할당할지 결정해야 함! -> 스케줄링 알고리즘

### 배정 조건
1. 공통 배정 조건: 오버헤드 ↓ / 사용률 ↑ / 기아 현상 ↓
- 오버헤드 : 프로세스가 필요한 자원보다 더 많이 사치부리며 사용하지 않도록
- 사용률 : 프로세스가 최대한 자원을 많이받고 빨리 처리하도록
- 기아 현상 : 프로세스가 자원할당을 못받아서 배고픈상태로 대기하지 않도록

2. 목표에 따른 배정 조건
- 배치 시스템 : 가능하면 많은 일을 수행. 시간(time) 보단 처리량(throughout)이 중요
- 대화형 시스템 : 빠른 응답 시간. 적은 대기 시간이 중요
- 실시간 시스템 : 실시간(time) 즉, 최소 응답시간(dead line)

### 스케쥴링 단위
- CPU와 I/O Burst Cycle: 프로세스 실행 동안 CPU와 입출력(I/O) 작업 사이를 번갈아가며 발생하는 주기를 나타냄

#### CPU Burst
- CPU가 프로세스를 실행하는 시간을 의미하며, 이 동안 프로세스는 CPU를 사용하여 계산 작업을 수행함
- 프로세스가 CPU에서 실행되는 시간의 길이를 의미!
- 각 프로세스는 CPU Burst 후 다음 단계로 진행하기 전에 I/O 작업을 수행해야 할 수 있음

#### I/O Burst
- 프로세스가 입출력 장치와 통신하거나 파일을 읽거나 쓰는 등의 입출력 작업을 수행하는 시간을 나타냄
- 프로세스가 I/O Burst를 수행하는 동안, CPU는 대기 상태가 되며 다른 프로세스에게 CPU를 양보
- I/O Burst의 길이는 프로세스가 입출력 작업을 처리하는 데 소요되는 시간

#### 평가 기준
- CPU이용률 : 전체 시스템 시간 중, CPU가 작업을 처리하는 시간의 비율
- 처리량 : CPU가 단위 시간당 처리하는 프로세스의 개수
- 총 처리 시간 : 프로세스가 시작해서 끝날때 까지 걸린 시간
- 대기시간 : 프로세스가 준비완료 큐에서 대기하는 시간의 총 합
- 응답시간 : 대화식 시스템에서 요청 후 첫 응답이 오기까지 걸린 시간

### 종류
#### 선점 스케쥴링 (Preemptive Scheduling)
- OS가 나서서 CPU사용권을 '선점'하고, 특정 요건에 따라 각 프로세스의 요청이 있을 때 프로세스에게 분배하는 방식
- 따라서 빠른 응답시간을 요하는 대화식 시분할 시스템에 적합하며 긴급한 프로세스를 제어

1. 우선순위 스케쥴링 (Priority Scheduling)
- 정적/동적으로 우선순위를 부여하여 우선순위가 높은 순서대로 처리
- 우선 순위가 낮은 프로세스가 무한정 기다리는 기아 현상 발생 가능 -> Aging 방법으로 기아현상 문제 해결 가능

2. 라운드로빈 (Round Robin)
- 정해진 시간 할당량 만큼 프로세스를 할당한 뒤, 작업이 끝난 프로세스는 준비완료 큐(순환 큐)의 가장 마지막에 가서 재할당을 기다리는 방법
- 시간 할당량이 중요한데, 너무 작으면 빈번한 문맥 전환(Context Switching)이 발생하고, 너무 길면 FCFS와 다를 바 없어짐

3. 다단계 큐 (Multilevel-Queue)
- 프로세스를 여러 개의 우선순위에 따라 분류하고 각각에 대한 별도의 큐를 유지하는 스케줄링 알고리즘
- 각 큐는 다른 우선순위 레벨을 가지며, 각 레벨마다 서로 다른 스케줄링 알고리즘을 사용할 수 있음
- 일반적으로 우선순위를 기준으로 프로세스를 분류
- 각 큐는 다른 우선순위 레벨을 가지고 있으며, 우선순위가 높은 큐에서 실행 가능한 프로세스가 먼저 선택되어 실행
- 각 큐는 다른 스케줄링 알고리즘을 사용할 수 있으므로, 각 우선순위 레벨에 맞게 적절한 스케줄링 알고리즘을 선택할 수 있음

#### 비선점 스케쥴링 (Non-Preemptive Scheduling)
- 어떤 프로세스가 CPU를 할당받으면 그 프로세스가 종료되거나, 입출력 요구가 발생하여 자발적으로 중지될 때 까지 계속 실행되도록 보장하는 방법
- 순서대로 처리되는 공정성이 있고, 다음에 처리해야할 프로세스와 상관없이 응답시간을 예상할 수 있음
- 장점: 선점방식보다 스케쥴러 호출 빈도가 낮고, 문맥교환에 의한 오버헤드가 적음
- 단점: 일괄처리 시스템에 적합하며 자칫 CPU사용시간이 긴 프로세스가 다른 프로세스들을 대기시킬 수 있으므로 처리율이 떨어질 수 있음

1. FCFS (First Come , First Serve)
- 먼저 도착한 프로세스를 먼저 처리하는 기본적인 스케쥴링 알고리즘
- Convoy Effect(호위효과)가 발생하는데, 긴 처리시간의 프로세스가 선점되어버리면 나머지 프로세스들은 끝날때 까지 대기해야 함 -> 평균 대기시간 편차가 큼

2. SJF (Shorted Job First)
- CPU버스트 타임이 가장 짦은, 최단작업을 우선 스케쥴링 하는 알고리즘 
- 현재 CPU에 할당된 프로세스의 남은 잔여시간과, 새로 들어온 프로세스의 CPU버스트 타임을 비교하여 더 적은 프로세스에게 할당하게끔 함.

3. HRN (Highest Response-ratio Next)
- 우선순위를 계산하여 점유 불평등 보완(SJF 단점 보완)

### 동작 시점
스케쥴링 알고리즘에 따라 프로세스들은 상태변화가 일어나며 준비/수행 상태일때 CPU를 사용하게 됨
1. 수행 -> 대기 (Running->Waiting) : I/O요청이 발생하거나, 자식 프로세스가 종료 대기를 할 때
2. 수행 -> 종료 (Running -> Terminate) : 프로세스를 종료시켰을 때
3. 수행 -> 준비 (Running-> Ready) : 인터럽트가 발생했을 때
4. 대기 -> 준비 (Waiting -> Ready) : I/O가 완료되었을 때

* * *
## 메모리 심화
### 지역성
1. 시간 지역성
- 최근 사용한 데이터에 다시 접근하려는 특성

2. 공간 지역성
- 최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하는 특성

### 캐시히트
- 캐시에 원하는 데이터를 찾은 것
- 위치도 가깝고 CPU 내부버스를 기반으로 작동하여 빠름
- 데이터를 제어장치를 거쳐 가져오게 됨

### 캐시미스
- 해당 데이터가 캐시에 없다면 주메모리로 가서 데이터를 찾아오는 것
- 메모리를 가져올때 시스템 버스를 기반으로 작동하기 때문에 느림

### 캐시 매핑
- 주기억장치와 캐시 메모리 간의 데이터 위치를 연결하는 방법
- 캐시가 히트되기 위해 매핑되는 방법

1. 직접 매핑
- 주기억장치와 캐시 메모리 간의 데이터 위치를 연결하는 방법
- 직접 매핑은 간단하고 빠르게 동작하지만, 캐시 충돌 문제가 발생

2. 연관 매핑
- 순서를 일치하지 않고 관련 있는 캐시와 메모리를 매핑
- 충돌이 적지만 모든 블록을 탐색하여 속도가 느림

3. 집합 연관 매핑
- 직접 매핑과 연관 매핑을 합쳐 놓은 것
- 순서는 일치하지만 집합을 둬서 저장하며 블록화되어 있어 검색이 효율적

### 할당
- 메모리에 프로그램을 할당할 때는 시작 메모리 위치, 메모리의 할당 크기를 기반으로 할당

#### 연속 할당
- 메모리에 '연속적으로' 공간을 할당하는 것

1. 고정 분할 방식
- 메모리를 미리 나누어 관리하는 방식
- 단점: 내부 단편화 발생

2. 가변 분할 방식
- 주기억장치를 동적으로 여러 개의 분할로 나누어 프로세스에게 할당하는 방식
- 각 프로세스는 필요한 만큼의 메모리 공간을 할당받으며, 프로세스의 크기에 따라 메모리 분할이 조정
- 크게 두 가지의 특징을 가지고 있음
> 내부 단편화: 들어갈 수 있는 공간보다 프로그램이 작아서 공간이 남아버리는 것
> 외부 단편화: 들어갈 공간보다 들어갈 것이 더 커서 들어가지 못하고 남아버리는 것

#### 불연속 할당
- 프로세스가 연속된 메모리 공간이 아닌 여러 개의 분산된 영역에 할당되는 방식
- 프로세스가 필요로 하는 메모리 공간을 더 효율적으로 활용하고, 외부 단편화 문제를 완화하기 위해 사용
- 주요한 두 가지 방식 존재

1. 페이징 (Paging)
- 동일한 크기의 페이지 단위 나누어 메모리의 서로 다른 위치에 프로세스를 할당
- 빈데이터(홀)의 크기가 균일하지 않은 문제가 없어지지만 주소 변환이 복잡

2. 세그먼테이션 (Segmentation)
- 세그먼트로 분할하는 방식
- 공유와 보안 측면에서 좋음
- 빈데이터(홀) 크기가 균일하지 않는 문제 발생

3. 페이지드 세그멘테이션 (Paged Segmentation)
- 페이징과 세그먼테이션을 결합한 방식
- 세그먼트로 분할하고, 각 세그먼트를 고정된 크기의 페이지로 나누어 메모리에 할당