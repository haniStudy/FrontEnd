# 자료와 자료구조
## 텍스티와 숫자 자료 표현의 단점
1. 큰 데이터는 단순 구조의 공간에 할당할 수 없음
2. 복잡한 데이터를 단순 구조로 저장할 경우 삽입/삭제가 어렵기 때문에 정렬도 어려움

## 선형 자료구조
- 데이터가 저장 순서대로 저장되는 자료구조
- 예: 배열, 연결 리스트, 스택, 큐 등
> 배열: 데이터를 연속적인 메모리 공간에 저장
> 연결 리스트: 데이터가 노드로 연결된 형태로 저장
> 스택: 데이터를 마지막에 삽입하고, 마지막에 삭제
> 큐: 데이터를 첫 번째에 삽입하고, 첫 번째에 삭제

## 비선형 자료구조
- 데이터가 저장 순서가 아닌 규칙에 따라 저장되는 자료구조
- 예: 트리, 그래프 등
> 트리: 데이터가 계층적으로 저장
> 그래프: 데이터가 노드와 엣지로 연결된 형태로 저장

* * *

## 배열 (Array)
- 연속적인 메모리 위치에 데이터를 저장
- 장점: 데이터의 순서 유지 가능, 빠르게 접근 가능
- 단점: 배열의 크키가 지정되어 있기 때문에 더 많은 데이터를 넣을 경우 배열 재할당 필요!
=> 데이터가 자주 추가&삭제 되지 않고, 읽고 수정하는 경우가 많을 때 배열을 사용하면 좋음

* * *

## 리스트 (LinkedList)
- 노드로 연결된 데이터를 저장
- 장점: 데이터를 추가하거나 삭제하는 것이 쉬움, 배열과 달리 크기를 지정하거나 변경할 필요 없음
- 단점: 데이터 순서 유지 불가, 빠르게 접근 불가능
=> 일반적으로 데이터의 추가, 삭제가 많은 경우 사용하면 좋음

* * *

## 스택 (Stack)
- 후입 선출 (LIFO, Last In First Out) -> 나중에 들어간 데이터가 먼저 나옴
- 예: ctrl+z(되돌리기)
![image](./img/%EC%8A%A4%ED%83%9D.png)

### 장점
1. 구현이 간단하고 이해하기가 쉬움
2. 메모리 관리 용이

### 단점
1, 스택의 크기를 미리 지정해야 함
2. 중간 데이터 접근 및 수정 X

### 함수
1. push(item): 스택의 맨 위에 새로운 항목을 추가
2. pop(): 스택의 맨 위에 있는 항목을 제거하고 반환
3. peek(): 스택의 맨 위에 있는 항목을 반환 (제거하지 않음)
4. isEmpty(): 스택이 비어 있는지 여부를 확인
5. size(): 스택에 저장된 항목의 개수를 반환

* * *

## 큐 (Queue)
- 선입 선출 (FIFO, First In First Out) -> 먼저 들어간 데이터가 먼저 나옴
- 예: 스케쥴링 (먼저 들어온 작업을 먼저 처리)
![image](./img/%ED%81%90.png)

### 장점
1. 구현이 간단하고 이해하기 쉬움
2. 요소의 추가와 제거가 상수 시간(O(1))에 이루어짐
3. 메모리 관리가 용이

### 단점
1. 크기를 제한해야 할 때 크기 제한을 설정해야 함
2. 요소의 추가와 제거가 큐의 앞과 뒤에서만 이루어잠
3. 중간 데이터 접근 및 수정 X

### 함수
1. enqueue(item): 큐의 뒤쪽에 새로운 항목을 추가
2. dequeue(): 큐의 앞쪽에 있는 항목을 제거하고 반환
3. peek(): 큐의 앞쪽에 있는 항목을 반환 (제거하지 않음)
4. isEmpty(): 큐가 비어 있는지 여부를 확인
5. size(): 큐에 저장된 항목의 개수를 반환

* * *

## 덱 (Deque, Double-ended Queue)
- 양쪽으로 넣고 뺄 수 있는 큐
![image](./img/%EB%8D%B1.png)

### 장점
1. 양쪽 끝에서의 삽입과 삭제가 모두 가능
2. 요소의 추가와 제거가 상수 시간(O(1))에 이루어짐
3. 큐와 스택의 특성을 모두 가지므로 다양한 자료 구조를 구현할 수 있음

### 단점
1. 구현이 복잡할 수 있음
2. 메모리 사용량이 크기 때문에 메모리 관리에 주의해야 함.

### 함수
1. pushFront(item): 덱의 맨 앞에 새로운 항목을 추가
2. pushBack(item): 덱의 맨 뒤에 새로운 항목을 추가
3. opFront(): 덱의 맨 앞에 있는 항목을 제거하고 반환
4. popBack(): 덱의 맨 뒤에 있는 항목을 제거하고 반환
5. peekFront(): 덱의 맨 앞에 있는 항목을 반환 (제거하지 않음)
6. peekBack(): 덱의 맨 뒤에 있는 항목을 반환 (제거하지 않음)
7. isEmpty(): 덱이 비어 있는지 여부를 확인
8. size(): 덱에 저장된 항목의 개수를 반환

* * *

## 맵 (Hash Table) => 내장 객체 Map 사용 
- 키와 값의 쌍을 저장
- 해쉬: 임의 값을 고정 길이로 변환
- 해쉬 테이블: 키 값의 연산에 의해 직접 접근이 가능한 데이터 구조
- 해쉬 함수: 키에 대해 산술 연산을 이용해 데이터 위치를 찾을 수 있는 함수, 일정한 규칙에 따라 키를 해시값으로 변환하여 출동을 최소화 해야 함
- 해쉬 값/ 해쉬 주소: 키를 해싱 함수로 연산해서 해쉬 값을 알아내고 이를 기반으로 해쉬 테이블에서 해당 키에 대한 데이터 위치를 일관성 있게 찾을 수 있음
- 슬롯: 한 개의 데이터를 저장할 수 있는 공간
- 저장할 데이터에 대해 키를 추출할 수 있는 별도 함수도 존재할 수 있음

### 장점
1. 데이터의 삽입, 삭제, 조회가 평균적으로 상수 시간(O(1))에 이루어짐
2. 대용량의 데이터를 효율적으로 관리할 수 있음
3. 해시 함수를 통해 빠른 검색이 가능

### 단점
1. 충돌이 발생할 경우 성능이 저하될 수 있음
2. 해시 함수의 선택이 중요하며 충돌을 최소화하기 위한 적절한 방법을 사용해야 함.
3. 메모리 공간을 많이 사용할 수 있음

### 동작 방식
1. 키를 해시 함수에 적용하여 해쉬 값 얻기
2. 해쉬 값을 배열의 인덱스로 사용하여 해당 인덱스에 키-값 쌍을 저장하거나 조회
3. 해쉬 충돌이 발생할 경우, 충돌을 해결하기 위한 방법을 사용
> 일반적으로 연결 리스트나 개방 주소법 등을 사용
> 체이닝: 연결리스트로 노드를 계속 추가해나가는 방식 (제한 없이 계속 연결 가능, but 메모리 문제)
> Open Addressing: 해시 함수로 얻은 주소가 아닌 다른 주소에 데이터를 저장할 수 있도록 허용 (해당 키 값에 저장되어있으면 다음 주소에 저장)
> 선형 탐사: 정해진 고정 폭으로 옮겨 해시값의 중복을 피함
> 제곱 탐사: 정해진 고정 폭을 제곱수로 옮겨 해시값의 중복을 피함

* * *

## 셋 (Set) => 내장 객체 Set 사용
- 중복되지 않는 유일한 값을 저장
- 순서라는 개념 X (비순차적으로 저장)
- 집합과 비슷한 개념
- 예: 이벤트 응모자 목록

### 장점
1. 중복 요소 제거
2. 값의 유일성 보장 (중복 X)
3. 순서 보장

### 단점
1. 값의 변경 불가능
2. 검색 속도 느림 (데이터가 많을 수록)

### 구조
- Set에서 요소들이 저장될 때 순서
    1. 저장할 요소의 값의 hash 값 구하기
    2. 해쉬값에 해당하는 공간(bucket)에 값을 저장
- 저장하고자 하는 값의 해쉬값에 해당하는 bucket에 값을 저장하기 때문에 순서 X,  순서가 없기 때문에 indexing X
- 해쉬값 기반의 bucket에 저장하기 때문에 중복된 값을 저장 X
- 해쉬값을 기반으로 저장하기 때문에 look up이 굉장히 빠름
    - Look up: 특정 값을 포함하고 있는지를 확인 하는것
    - O(1): Set의 총 길이와 상관없이 단순히 해쉬값 계산 후 해당 bucket을 확인하면 됨

### HashSet
- 내부적으로 HashMap을 사용하여 값을 저장
- 값의 중복을 허용 X
- 값이 저장된 순서를 보장 X
- null 을 허용