# useCallback
> 인자로 들어오는 함수 자체를 기억 (메모이제이션)
> 사용하는 이유
> > 다른 훅을 이용해 리렌더링 되지 않도록 해도 함수형 컴포넌트를 사용하는 경우 리렌더링 발생할 수 있음
> > > 렌더링 -> component 함수 호출 -> 모든 내부 변수 초기화
> > > 함수고 객체의 한 종류, 다시 생성하게 되면 주소 값 변경 -> 하위 컴포넌트에서 변경되었다고 인식됨


## 구조
> useCallback(() => {}, []);
> 매개변수: 0: 콜백 함수, 1: 의존성 배열


### 코드 예시
<pre>
    <code>
        // count를 초기화해주는 함수
        const initCount = useCallback(() => {
            console.log(`[COUNT 변경] ${count}에서 0으로 변경되었습니다.`);
            setCount(0);
        }, [count]);
        // 의존성 배열을 넣어줘야지 console.log 내에 변경된 count 값 저장
        // 넣어주지 않으면 이전 상태 값을 가져와서 0이 출력됨 (스냅샷)
    </code>
</pre>