# useEffect
## 질문
useEffect의 실행 순서에 대해 설명해주세요.

## 답변
useEffect의 실행은 컴포넌트의 렌더링과 동시에 일어나는 것이 아니라 이후에 일어납니다.
의존성 배열 값을 확인한 후 이전 값과 현재 값들을 비교한 후 변화가 없으면 콜백 함수를 실행하지 않습니다. 
만약 변화가 있다면 콜백 함수가 실행되는데 클린업 함수가 있다면 새로운 렌더링이 일어나기 전 클린업 함수가 실행됩니다. (이전 작업 정리 후 메모리 누수 방지)
마지막으로 컴포넌트의 렌더링이 완료되고 화면에 반영됩니다.

* * *
## useEffect란?
- 컴포넌트가 렌더링 될 때, 특정 작업을 실행할 수 있도록 하는 hook
> 처음 마운트 될 때
> 컴포넌트가 리렌더링 될 때
> 선언된 변수의 값이 변경 될 때
> redux store의 값이 변경될 때

## 대표적인 예
- 타이머 설정
- 외부 라이브러리와의 상호 작용 등

## 장점
1. 비동기 작업 처리
- 데이터 가져오기, 변경 사항 저장 등과 같은 비동기 작업을 쉽게 처리할 수 있음
> 비동기 작업
> > 특정 코드의 실행이 다른 코드의 실행에 영향을 받지 않고 독립적으로 실행되는 것을 의미
> > 즉, 비동기 작업을 수행하는 코드가 실행되어도 다음 코드가 기다리지 않고 바로 다음 코드가 실행
> > 작업이 완료되기를 기다리지 않고, 작업이 완료되면 특정 콜백 함수나 프로미스를 통해 결과를 처리하는 방식
> > 비동기 작업은 애플리케이션의 성능, 반응성, 복잡성 관리, 자원 효율성 및 오류 처리 측면에서 중요함
> > 애플리케이션이 다양한 작업을 효율적으로 처리하고, 사용자 경험을 향상시키기 위해 비동기 작업을 적절하게 활용하는 것이 필요!

2. 리소스 해제
- 컴포넌트가 언마운트(마운트 해제 될 때) 또는 이전 작업을 정리(cleanup) 할 수 있도록 해줌
- 메모리 누수를 방지하고, 애플리케이션 성능을 향상 시킴

## 단점
1. 렌더링마다 실행
- 해당 hook의 콜백은 컴포넌트가 렌러딩 될 때 마다 실행 됨
- 때때로 불필요한 작업을 반복 수행할 수 있으므로 주의가 필요!

2. 의존성 배열 관리
- 의존성 배열을 관리하지 않으면 불필요한 리렌더링 발생할 가능성 있음

## 어떤 상황에 사용하면 좋을까?
1. 데이터 가져오기
- 서버에서 데이터를 가져와 컴포넌트에 표시해야 할 때

2. 이벤트 리스너 등록
- 이벤트 리스너를 등록하고, 컴포넌트가 언마운트될 때 이벤트 리스너를 제거 할 때

3. 타이머 설정
- 타이머를 설정하고, 컴포넌트가 언마운트될 때 타이머를 해제할 때

## 어떤 상황에 사용하면 안좋을까?
1. 매 렌더링마다 실행되어야 하는 작업이 아닌 경우
2. 의존성 배열을 올바르게 설정하기 어려운 경우
3. 클래스 컴포넌트로 구현해야 하는 경우